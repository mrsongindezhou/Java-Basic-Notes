
# Redis 常见问题
Redis是完全开源免费的高性能KV分布式内存数据库，它可以用作数据库、缓存和消息中间件。 
## 一. 为什么 Redis 在单线程下能如此快？
1. 基于纯内存操作：
    -  绝大多数请求都是纯粹的内存操作，速度非常快。数据存储在内存中，与HashMap类似，HashMap的优点是搜索和操作的时间复杂度为O（1）；
2. 数据结构简单，数据操作简单。
    - Redis中的数据结构是专门设计的；
3. 单线程操作，避免频繁上下文切换和条件竞争。
    - 没有消耗CPU的多进程或多线程切换。
    - 不需要考虑各种锁的问题。
    - 没有锁释放操作，没有可能的死锁导致的性能消耗；
4. 采用了非阻塞I/O多路复用,I/O多路复用简单流程如下：
    -  redis-client在操作的时候会产生不同事件的socket。
    -  server端的I/O多路复用程序将其置入队列中。
    -  文件事件分派器依次去队列中取，转发到不同的事件处理器中。
    -  这个I/O多路复用机制，Redis采用evport，epoll，kqueue和select四种方式实现多路复用，增加链接处理，默认是epoll。
5. 基于自己构建的基础模型
    - 客户端和客户端之间的底层实现和通信协议是不同的,是Redis直接自己构建VM机制。如果一般的系统调用系统函数，这种请求调用会浪费一定的时间。 
## 二. Redis 有几种数据结构？Zset 是如何实现的？
Redis支持多种类型的数据结构
1. String: 是 redis 最基本的类型, value可以是String也可以是数字。
    - String 是二进制安全。
    - 
1. List:简单的字符串列表，按照插入顺序排序。
    - 可以添加一个元素到列表的头部（左边）或者尾部（右边）。
    - 是链表(双向链表)实现的。
    - 可以做简单的消息队列功能。
    - 可以利用lrange做基于redis的分页功能
1. Hash:value是一个键值(key=>value)对集合。
    - Hash 特别适合用于存储对象。例如用户信息中有name,age等信息。
1. Set:Set是string类型不重复的无序集合。
    - 哈希表实现,元素不重复
    - 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。
1. ZSet：将Set中的元素增加一个权重参数score,元素按score有序排列
    - 基于跳表实现的
    - 数据插入集合时,已经进行天然排序
    - 可以做排行榜，取TopK的操作
1. BitMaps:提供位级操作。
1. HyperLogLogs 
    -  是用来做基数统计的算法
    -  优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。
1. GEO（geospatial） 
    - 存储地理位置信息，并对存储的信息进行操作

## 三. 简述 Redis 中跳表的应用以及优缺点
- Redis使用跳表是为了实现sortedset的数据结构。
- 跳表是一种随机化数据结构构。
- 它的效率和红黑树以及 AVL树不相上下，但实现起来比较容易。
    - 跳表结构：跳表分为许多层(level)，每一层都可以看作是数据的索引，这些索引的意义就是加快跳表查找数据速度。每一层的数据都是有序的，上一层数据是下一层数据的子集，并且第一层(level 1)包含了全部的数据；层次越高，跳跃性越大，包含的数据越少。
        - 表头（head）：负责维护跳跃表的节点指针。
        - 跳跃表节点：保存着元素值，以及多个层
        - 层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。
    - 跳表查找：跳表包含一个表头，它查找数据时，是从上往下，从左往右进行查找。
### Redis中为什么不用红黑树二用跳表？
1. 插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；
1. 更容易实现；
1. 支持无锁操作。
## 四. 简述 Redis 持久化中 rdb 以及 aof 方案的优缺点
Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。
### 1. RDB(Redis Database) 持久化
- RDB持久化是通过快照的方式，即在指定的时间间隔内将内存中的数据集快照写入磁盘。
- RDB是Redis默认的持久化方式。
    1. 将某个时间点的所有数据都存放到硬盘上。
    1. 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。
    1. 如果系统发生故障，将会丢失最后一次创建快照之后的数据。
    1. 如果数据量很大，保存快照的时间会很长。
### 2. AOF（Append Only File）持久化
- AOF持久化会把被执行的写命令写到AOF文件的末尾，记录数据的变化。
- 使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。
- 对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。
- 有以下同步选项：

选项 | 同步频率 | 优缺点分析
---|---|---
always | 每个写命令都同步 | 会严重减低服务器的性能
everysec | 每秒同步一次 | 比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且每秒执行一次同步对服务器性能几乎没有任何影响
no | 让操作系统来决定何时同步 | 不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量

### 3. 优缺点
i. RDB
- 优点 
    - 1. 数据结构紧凑：RDB快照是一个压缩过的非常紧凑的文件，适合做数据的备份，灾难恢复
    - 2. 最大化Redis的性能：在保存RDB文件，服务器进程只需fork一个子进程来完成RDB文件的创建，父进程不需要做IO操作
    - 3. 恢复大数据集的时候会更快
- 缺点
    - 1. 数据安全性是不如AOF：保存整个数据集的过程是比繁重的，根据配置可能要几分钟才快照一次，如果服务器宕机，那么就可能丢失几分钟的数据
    - 2. 持久化过程中对服务器性能影响大：数据集较大时，fork的子进程要完成快照会比较耗CPU、耗时
ii. AOF
- 优点 
    - 1. 数据更完整，安全性更高，秒级数据丢失(fsync = everysec)
    - 2. 适合紧急恢复：AOF日志是一个只进行追加的日志，因此在断电的情况下没有查找和损坏问题。即使由于某种原因（磁盘已满或其他原因）日志以半写命令结束，redis check aof工具也能够轻松地修复它。
- 缺点
    - 1. 对于相同的数据集，AOF文件的体积要大于RDB文件，数据恢复也会比较慢
    - 2. 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。 

### 4. RDB和AOF使用场景
- 不持久化：如果是数据不那么敏感，且可以从其他地方重新生成补回的，那么可以关闭持久化
- RDB持久化：如果是数据比较重要，不想再从其他地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只使用RDB
- RDB+AOF持久化：如果是用做内存数据库，要使用Redis的持久化，建议是RDB和AOF都开启，或者定期执行bgsave做快照备份，AOF可以保证数据的不丢失

## 五. Redis的缓存淘汰策略有哪些？
1. noeviction：如果内存达到最大限制，且客户端尝试执行一些增加内存的命令时，会**返回错误**。
1. allkeys-lru：如果内存达到最大限制，通过尝试先删除最近最少使用的key（LRU）。
1. volatile-lru：如果内存达到最大限制，仅在**已设置了expire set的key**中，移除最近最少使用的key。
1. allkeys-random：随机移除key。
1. volatile-random：仅在**已设置了expire set的key**中随机移除key。
1. volatile-ttl：也仅移除带有过期时间的key，会根据生存时间来排序，优先逐出 TTL 短的。

## 六. 简述 Redis 中如何防止缓存雪崩和缓存击穿
### 1. 缓存穿透
在大多数互联网应用程序中：
当业务系统发起某个查询请求时，首先判断数据是否存在于缓存中；
如果有缓存，直接返回数据；
如果缓存不存在，请再次查询数据库并返回数据。
#### 1.1 什么是缓存渗透？
缓存穿透：
- 业务系统要查询的数据根本就不存在！
- 当业务系统发起查询时，按照上面的流程，查询会先去缓存。
- 因为缓存不存在，然后再去数据库查询。
- 因为数据根本不存在，所以数据库也返回null。
- 综上所述：业务系统访问根本不存在的数据称为缓存穿透。
#### 1.2 缓存渗透的危害
- 增加数据库压力：如果查询请求中存在大量不存在的数据，那么这些大量的请求就会落入数据库中，数据库压力会急剧增加，从而导致系统崩溃。
#### 1.3 为什么会发生缓存渗透？
- 恶意攻击：恶意攻击故意创建大量不存在的数据来请求我们的服务。由于缓存中不存在这些数据，大量请求会落入数据库，这可能会导致数据库崩溃。
- 代码逻辑错误。
#### 1.4 缓存穿透解决方案
i. 缓存空数据
- 可以将带有空数据库查询结果的密钥存储在缓存中。
- 当再次出现对密钥的查询请求时，缓存直接返回null而不查询数据库。

ii. 过滤器(BloomFilter)
- 在缓存之前添加一个屏障，该屏障存储当前数据库中存在的所有密钥。
- 当有一个查询请求时，首先转到BloomFilter检查是否存在该键。
- 如果不存在，则表示数据库中不存在该数据，因此不应检查缓存，直接返回null。
- 如果存在，则继续执行后续过程，首先转到缓存进行查询，如果没有缓存，则转到数据库中的查询。
iii. 两种方案比较
这两种解决方案都可以解决缓存穿透问题，但使用场景不同。
- 缓存空数据:无效数据数据key个数有限、key重复请求概率高的场景，应选择第一种方案。
- 过滤器(BloomFilter)：恶意攻击中查询的key往往不同，key的数量比较多，不适合缓存这些无效数据

### 2. 缓存雪崩
#### 2.1 什么是缓存雪崩？
缓存雪崩： (DB崩)如果缓存由于某种原因而关闭，最初被缓存阻止的大量查询请求将全部涌向数据库。此时，如果数据库无法承受如此巨大的压力，它将崩溃。
#### 2.2 如何避免缓存雪崩？
i. 使用缓存集群确保缓存的高可用性
- 在雪崩发生前，采取预防措施，防止雪崩的发生。

ii. 使用Hystrix
- Hystrix是一个开源的“反雪崩工具”，它通过降级、限流来减少雪崩后的损失。

### 3. 热点数据无效
#### 3.1 热点数据集故障是什么？

- **数据有过期时间**：我们通常为缓存设置一个过期时间。过期时间过后，缓存会直接删除数据库，从而在一定程度上保证了数据的实时性。
- **热点数据的移除缓存**：但是，对于一些请求非常高的热数据，一旦超过有效时间，此时会有大量的请求落在数据库上，这可能会导致数据库崩溃。
- **请求落到DB**: 如果热点数据失败，那么当再次出现数据查询请求时，它将转到数据库查询。
- **更新缓存之前，所有请求都到DB**: 然而，从请求被发送到数据库到数据被更新到缓存中，由于数据仍然不在缓存中，这段时间内到达的查询请求将落在数据库上，这将给数据库带来巨大的压力。
- **重复更新缓存**：此外，当这些请求查询完成时，缓存会重复更新。

#### 3.2 解决方案
i. 互斥
可以使用缓存附带的锁机制
- 当第一个数据库查询请求启动时，缓存中的数据将被锁定；
- 此时，到达缓存的其他查询请求将无法查询该字段，因此将被阻止等待；
- 当一个请求完成数据库查询并缓存数据更新值后，锁被释放；
- 此时，其他被阻止的请求将被阻止等待查询请求可以直接从缓存中检索。
- **缺点**： 用互斥锁，其他请求将阻塞等待，系统的吞吐量将下降。

ii. 设置不同的过期时间
- 将数据存储在缓存中时，我们可以错开它们的缓存过期时间。
- 这样可以避免同时发生故障。
- 例如，在基准时间加/减一个随机数以错开这些缓存的过期时间。

## 七. Redis 中，sentinel 和 cluster 的区别和适用场景是什么？

### 1. sentinel 和 cluster 是什么？

#### Redis主要有两种类型运行多个实例。
- 使用“标准复制”的Sentinel
- Redis Cluster。Cluster要管理自身，也可以将HA+复制两者结合起来进行扩展。

#### i. Redis Cluster
Redis Cluster主要是一种跨多个实例自动分片数据的方法。它是在Redis3.0中发布。
#### Redis Cluster的作用
- Redis Cluster被配置为在给定数量的Redis实例上分布数据。
- 为了管理数据所在的位置，集群有一个协议规范，允许客户机与集群中的任何主机通信。
- 如果正在操作的钥匙存储在本地，数据将正常返回。
- 如果数据存储在另一个节点上，则会返回一个MOVED响应，告诉客户机要与哪个主机进行对话。因此，这种机制需要对Cluster的客户端支持
- 请注意，集群不直接提供HA或复制。

#### Cluster的用途是什么
集群的用例围绕着分散负载（特别是写操作）和超越单实例内存能力展开。
- 如果对一系列Key有很高的写入量，并且您的客户机库支持集群，那么集群也将是一个很好的选择。

#### Cluster的优缺点

**优点**
- 无中心架构。
- 数据按照slot存储分布在多个redis实例上。
- 增加slave做standby数据副本，用于failover，使集群快速恢复。
- 实现故障auto failover。节点之间通过gossip协议交换状态信息；投票机制完成slave到master角色的提升。
- 亦可manual failover，为升级和迁移提供可操作方案。
- 降低硬件成本和运维成本，提高系统的扩展性和可用性。

**缺点**
- client实现复杂，驱动要求实现smart client，缓存slots mapping信息并及时更新。
- 客户端的不成熟，影响应用的稳定性，提高开发难度。
- 节点会因为某些原因发生阻塞(阻塞时间大于clutser-node-timeout），被判断下线。这种failover是没有必要，sentinel也存在这种切换场景。

#### ii. Redis sentinel(哨兵)
Redis支持多个从机从主节点复制数据。这提供了一个备份节点，其中包含您的数据，可以随时提供数据。但是，为了提供自动故障切换，您需要一些工具。对于Redis，这个工具叫做Sentinel。




#### Redis sentinel的作用
- Sentinel配置为指向您需要管理的主机。
- 它将向主服务器查询所有连接的从属服务器。
- 一旦确定了pod的配置，它将继续监视每个节点，在确认一个主节点关闭后，它将提升一个从节点，并重新配置每个从节点以指向新的主节点。

**虚拟IP/负载平衡**: 为了将其用于透明的客户机连接管理，需要将主节点放在虚拟IP后面，或者放在可以动态配置哪个节点是主节点的负载平衡后面。

**Redis sentinel的特点**:
Sentinel使用投票+仲裁机制，因此至少需要三个Sentinel节点协同工作。在这个场景中，您可以使用Sentinel进行服务发现。
#### Redis sentinel的优缺点
**优点**
- sharding逻辑对开发透明，读写方式和单个redis一致。
- 可以作为cache和storage的proxy（by auto-eject）。

**缺点**
- 架构复杂，层次多。包括lvs、twemproxy、redis、sentinel和其控制层程序。
- 管理成本和硬件成本很高。


#### iii. 适用场景
Cluster：如果内存需求超过了系统内存，或者需要跨多个节点分发写操作以保持性能级别，那么应该用Redis Cluster。
Sentinel： 如果正在寻找高可用性，那么将需要更多地考虑部署Sentinel。




## 八. Redis 如何实现分布式锁？
#### 为什么需要分布式锁
在不同进程需要互斥地访问共享资源时，分布式锁是一种非常有用的技术手段。
#### 高效分布式锁的基础
1. 安全属性：互斥，不管任何时候，只有一个客户端能持有同一个锁。
1. 效率属性A：不会死锁，最终一定会得到锁，就算一个持有锁的客户端宕掉或者发生网络分区。
1. 效率属性B：容错，只要大多数Redis节点正常工作，客户端应该都能获取和释放锁。

#### 采用单实例的正确实现 （Set NX）

1. 获取锁：使用用下面这个命令来获得锁，

```
SET resource_name my_random_value NX PX 30000
```
其中这个key的值设为“my_random_value”。这个值必须在所有获取锁请求的客户端里保持唯一的，这个随机值就是用来做当前客户端的校验，保证能安全地释放锁，不会被其他的客户端删除。

2. 释放锁可以用下面这个Lua脚本来告诉Redis：删除这个key当且仅当这个key存在而且值是我期望的那个值。

```
if redis.call("get",KEYS[1]) == ARGV[1] then
        return redis.call("del",KEYS[1])
    else
        return 0
    end
```

3. 设置超时时间：key值的超时时间，也叫做”锁有效时间”。这个是锁的自动释放时间，也是一个客户端在其他客户端能抢占锁之前可以执行任务的时间，这个时间从获取锁的时间点开始计算。

#### Redlock算法
假设我们有N个Redismaster节点，这些节点都是完全独立的， 假设N = 5。
1. 一个客户端需要做如下操作来获取锁：
- i.获取当前时间（单位是毫秒）。
- ii.轮流用相同的key和随机值在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。
- iii.客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（在这里是3个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。
- iv.如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。
- v.如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。

2. 释放锁
释放锁比较简单，因为只需要在所有节点都释放锁就行，不管之前有没有在该节点获取锁成功。

### Ref:
- https://redis.io/topics/persistence
- https://redis.io/topics/benchmarks
- https://redis.io/topics/data-types-intro
- https://redis.io/topics/lru-cache
- http://23.253.120.235/sentinel-or-cluster/
- https://redis.io/topics/distlock
- https://medium.com/@mena.meseha/3-major-problems-and-solutions-in-the-cache-world-155ecae41d4f