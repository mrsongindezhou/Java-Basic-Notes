## 微服务和RPC
### 服务化

随着数据量、并发量、业务复杂度的增长，互联网架构会出现以下问题：
- （1）代码到处拷贝
- （2）底层复杂性扩散
- （3）基础库（so/jar/dll）耦合
- （4）SQL质量得不到保障，业务相互影响
- （5）数据库耦合
“服务化”是一个很好的解决上述痛点的方案。
服务化的一个好处就是，不限定服务的提供方使用什么技术选型，能够实现大公司跨团队的技术解耦。

### 微服务的粒度
一个子业务一个service
垂直拆分是个好的方案，将子业务一个个拆出来
服务粒度变细之后，出现一个新的问题，业务与服务的连接关系变复杂。
解决方案： 加入一个高可用服务分发层集群，并在协议设计时加入服务号，可以减少蜘蛛网状的依赖关系：
- （1）调用方依赖分发层，传入服务号
- （2）分发层依赖服务层，通过服务号参数分发

### RPC
RPC（Remote Procedure Call Protocol），远程过程调用
#### RPC的作用
- 如果没有统一的服务框架，RPC框架，各个团队的服务提供方就需要各自实现一套序列化、反序列化、网络框架、连接池、收发线程、超时处理、状态机等“业务之外”的重复技术劳动，造成整体的低效。
- 所以，统一RPC框架把上述“业务之外”的技术劳动统一处理，是服务化首要解决的问题。

#### RPC的职责
- 本地函数调用：传入数据，传出数据，代码段在同一个进程空间里
- 跨进程（远程）函数调用：类似的，可以两个进程约定一个协议格式，使用Socket通信，来传输【入参】【调用哪个函数】【出参】。
RPC框架要向调用方屏蔽各种复杂性，要向服务提供方也屏蔽各类复杂性：
（1）调用方感觉就像调用本地函数一样
（2）服务提供方感觉就像实现一个本地函数一样来实现服务


#### RPC的组成
RPC框架分为client部分与server部分
- client端包含：序列化、反序列化、连接池管理、负载均衡、故障转移、队列管理，超时管理、异步管理等等等等职责。
- server端包含：服务端组件、服务端收发包队列、io线程、工作线程、序列化反序列化、上下文管理器、超时管理、异步回调等等等等职责。

#### RPC-client同步调用
工作线程的串行执行步骤：

- 1）业务代码发起RPC调用，Result=Add(Obj1,Obj2)
- 2）序列化组件，将对象调用序列化成二进制字节流，可理解为一个待发送的包packet1
- 3）通过连接池组件拿到一个可用的连接connection
- 4）通过连接connection将包packet1发送给RPC-server
- 5）发送包在网络传输，发给RPC-server
- 6）响应包在网络传输，发回给RPC-client
- 7）通过连接connection从RPC-server收取响应包packet2
- 8）通过连接池组件，将conneciont放回连接池
- 9）序列化组件，将packet2范序列化为Result对象返回给调用方
- 10）业务代码获取Result结果，工作线程继续往下走

#### RPC-client异步回调

1）业务代码发起异步RPC调用，Add(Obj1,Obj2, callback)

2）上下文管理器，将请求，回调，上下文存储起来

3）序列化组件，将对象调用序列化成二进制字节流，可理解为一个待发送的包packet1

4）下游收发队列，将报文放入“待发送队列”，此时调用返回，不会阻塞工作线程

5）下游收发线程，将报文从“待发送队列”中取出，通过连接池组件拿到一个可用的连接connection

6）通过连接connection将包packet1发送给RPC-server

7）发送包在网络传输，发给RPC-server

8）响应包在网络传输，发回给RPC-client

9）通过连接connection从RPC-server收取响应包packet2

10）下游收发线程，将报文放入“已接受队列”，通过连接池组件，将conneciont放回连接池

11）下游收发队列里，报文被取出，此时回调将要开始，不会阻塞工作线程

12）序列化组件，将packet2范序列化为Result对象

13）上下文管理器，将结果，回调，上下文取出

14）通过callback回调业务代码，返回Result结果，工作线程继续往下走


###### 如果请求长时间不返回，处理流程是：

15）上下文管理器，请求长时间没有返回

16）超时管理器拿到超时的上下文

17）通过timeout_cb回调业务代码，工作线程继续往下走

###### 为什么需要上下文管理器？

- 由于请求包的发送，响应包的回调都是异步的，甚至不在同一个工作线程中完成，需要一个组件来记录一个请求的上下文，把请求-响应-回调等一些信息匹配起来。


###### 如何将请求-响应-回调这些信息匹配起来？

是通过一条连接往下游服务发送了a，b，c三个请求包，异步的收到了x，y，z三个响应包：

响应包匹配
（1）怎么知道哪个请求包与哪个响应包对应？
（2）怎么知道哪个响应包与哪个回调函数对应？
回答：这是通过【请求id】来实现请求-响应-回调的串联的。

通过请求id，上下文管理器来对应请求-响应-callback之间的映射关系：
- 1）生成请求id
- 2）生成请求上下文context，上下文中包含发送时间time，回调函数callback等信息
- 3）上下文管理器记录req-id与上下文context的映射关系，
- 4）将req-id打在请求包里发给RPC-server
- 5）RPC-server将req-id打在响应包里返回
- 6）由响应包中的req-id，通过上下文管理器找到原来的上下文context
- 7）从上下文context中拿到回调函数callback
- 8）callback将Result带回，推动业务的进一步执行



### 4种典型RPC远程调用框架
（1）RMI实现，利用java.rmi包实现，基于Java远程方法协议(Java Remote Method Protocol)和java的原生序列化。

（2）Hessian，是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 基于HTTP协议，采用二进制编解码。

（3）thrift是一种可伸缩的跨语言服务的软件框架。thrift允许你定义一个描述文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。

（4）dubbo，阿里的RPC框架。

（5）还有SpringCloud框架，微服务全家桶。为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。

微服务在本质上，就是rpc。rpc有基于tcp的，http的，mq的等等。spring cloud是基于spring boot的，spring boot 实现的是http协议的rpc，算是rpc的一个子集。