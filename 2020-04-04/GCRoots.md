## 简述 GC 引用链
#### GC的时候如何判断对象是否已经死亡？
##### 1. 引用计数算法
- 方法： 给对象添加一个计算器，一旦有地方引用该对象，则计数器加一，当引用失效时，就减一。任何计数器为 0 的对象，就不能再使用了。
- 问题：对象之间相互循环引用的问题。
##### 2. 可达性分析算法
- 方法： 通过一系列称为 “GC Roots” 对象作为起始点，从这些节点开始向下搜索，其所走过的路径称为引用链，当一个对象到 GC Roots 不可达时，则该对象是不可用的，也就是这些对象为可回收的。
-  GC Roots 对象：
    - 虚拟机栈（栈帧的本地变量表）中引用的本地对象
    - 方法区中类静态属性、常量引用的对象
    - 本地方法栈中 JNI 引用的对象
- 特别注意
    - 可达性分析 仅仅只是判断对象是否可达，但还不足以判断对象是否存活 / 死亡
    - 当在 可达性分析 中判断不可达的对象，只是“被判刑”  = 还没真正死亡
    -  不可达对象会被放在”即将回收“的集合里。
##### 3. 执行步骤
- 要判断一个对象真正死亡，还需要经历两个阶段： 
    - 第一次标记 & 筛选
    - 第二次标记 & 筛选

###### 3.1 第一次标记 & 筛选
对象 在 可达性分析中 被判断为不可达后，会被**第一次标记** & **准备被筛选**
-  a. 不筛选：继续留在 “即将回收”的集合里，等待回收；
-  b. 筛选：从 “即将回收”的集合取出

筛选的标准：该对象是否有必要执行 finalize()方法 
- 若有必要执行（人为设置），则筛选出来，进入下一阶段（第二次标记 & 筛选）；
- 若没必要执行，判断该对象死亡，不筛选 并等待回收
    -  当对象无 finalize()方法 或 finalize()已被虚拟机调用过，则视为“没必要执”

###### 3.2 第二次标记 & 筛选
当对象经过了第一次的标记 & 筛选，会被进行第二次标记 & 准备被进行 筛选

- a. 方式描述

该对象会被放到一个 F-Queue 队列中，并由 虚拟机自动建立、优先级低的Finalizer 线程去执行 队列中该对象的finalize() 
- finalize()只会被执行一次
- 但并不承诺等待finalize()运行结束。
    - 这是为了防止 finalize()执行缓慢 / 停止  使得 F-Queue队列其他对象永久等待。
- b. 筛选标准

在执行finalize()过程中，若对象依然没与引用链上的GC Roots 直接关联 或 间接关联（即关联上与GC Roots 关联的对象），那么该对象将被判断死亡，不筛选（留在“即将回收”集合里） 并 等待回收

