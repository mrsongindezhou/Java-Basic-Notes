## MinorGC 和 Full GC


#### 一. 简介
1. 在JVM的内存空间中把堆空间分为年老代和年轻代。
1. 将大量（据说是90%以上）创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。
1. 年轻代中又被分为Eden区、和两个Survivor区。
1. 新的对象分配是首先放在Eden区，Survivor区作为Eden区和Old区的缓冲，在Survivor区的对象经历若干次收集仍然存活的，就会被转移到年老区。


### 二. MinorGC 和 Full GC区别
- 新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。
- 老年代 GC（Major GC/Full GC）:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。

#### 三. MinorGC
基于大多数新生对象都会在GC中被收回的假设。新生代的GC 使用复制算法。
- 在GC前To 幸存区==(survivor)保持清空==,对象保存在 Eden 和 From 幸存区(survivor)中
- GC运行时,==Eden中的幸存对象被复制到 To 幸存区(survivor)==。
- 针对 ==From== 幸存区(survivor)中的幸存对象，会考虑对象年龄,如果年龄没达到阀值(tenuring threshold)，对象会==被复制到To 幸存区(survivor)==。
- 如果达到阀值对象被==复制到老年代==。
- 复制阶段完成后，Eden 和From 幸存区中只保存死对象，可以视为清空。
- 如果在复制过程中==To 幸存区被填满了==，剩余的对象会被复制到老年代中。
- 最后 ==From 幸存区和 To幸存区会调换下名字==，在下次GC时，To 幸存区会成为From 幸存区。



### 四. MinorGC 和 Full GC触发条件
1. Minor GC触发条件：**Eden区满时**
2. Full GC触发条件：
- （1）调用**System.gc**时，系统建议执行Full GC，但是不必然执行
- （2）**老年**代空间不足
- （3）**方法区**空间不足
- （4）通过Minor GC后进入老年代的平均大小大于老年代的**可用内存**
- （5）由Eden区、From Space区向To Space区复制时，对象**大小大于To Space**可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。


### 五. 对象进入老年代的四种情况
- (1) 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代
- (2) 大对象直接进入老年代
    - 假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代
- (3) 长期存活的对象将进入老年代
    - 此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没"熬过"一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中
- (4) 动态对象年龄判定
    - 还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。