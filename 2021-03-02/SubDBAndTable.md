## 简述数据库中什么情况下进行分库，什么情况下进行分表？

### 为什么要分库分表？
首先回答一下为什么要分库分表，答案很简单：数据库出现性能瓶颈。用大白话来说就是数据库快扛不住了。

数据库出现性能瓶颈，对外表现有几个方面：

1. 大量请求阻塞：在高并发场景下，大量请求都需要操作数据库，导致连接数不够了，请求处于阻塞状态。
1. SQL 操作变慢：如果数据库中存在一张上亿数据量的表，一条 SQL 没有命中索引会全表扫描，这个查询耗时会非常久。
1. 存储出现问题：业务量剧增，单库数据量越来越大，给存储造成巨大压力。
1. 从机器的角度看，性能瓶颈无非就是 CPU、内存、磁盘、网络这些，要解决性能瓶颈最简单粗暴的办法就是提升机器性能，但是通过这种方法成本和收益投入比往往又太高了，不划算，所以重点还是要从软件角度入手。


### 分库分表详解
下面我们以一个商城系统为例逐步讲解数据库是如何一步步演进。
#### 1. 单应用单数据库
- 单体架构应用：最早基本就是一个系统包含多个基础功能模块，最后打包成一个 war包部署，这就是典型的单体架构应用。因为用户量不大，这样的架构在早期完全适用。
- 例如商城系统包括用户模块、订单模块、库存模块等，所有的模块都共有一个数据库，通常数据库中有非常多的表。
#### 2. 多应用单数据库
- 随着系统访问压力逐渐增加，系统拆分就势在必行了。
- 为了保证业务平滑，系统架构重构也是分了几个阶段进行:
    - 第一个阶段将商城系统单体架构按照功能模块拆分为子服务，比如：用户服务、订单服务、库存服务等。
    - 多个服务共享一个数据库，这样做的目的是底层数据库访问逻辑可以不用动，将影响降到最低。
#### 3. 多应用多数据库
- 分库情况：随着业务推广力度加大，数据库终于成为了瓶颈，这个时候多个服务共享一个数据库基本不可行了。需要将每个服务相关的表拆出来单独建立一个数据库，这其实就是“分库”了。
- 单数据库的能够支撑的并发量是有限的，拆成多个库可以使服务间不用竞争，提升服务的性能。
- 从一个大的数据中分出多个小的数据库，每个服务都对应一个数据库，这就是系统发展到一定阶段必要要做的“分库”操作。
#### 4. 分表
- 如果系统处于高速发展阶段，例如商城系中说，一天下单量可能几十万，那数据库中的订单表增长就特别快，增长到一定阶段数据库查询效率就会出现明显下降。
##### 那如何分表呢？
- 分表有几个维度，一是水平切分和垂直切分，二是单库内分表和多库内分表。
- 垂直切分：
    - 用户表（user）来说，表中有7个字段：id、name、age、sex、nickname、description。如果 nickname 和 description 不常用，我们可以将其拆分为另外一张表：用户详细信息表。
    - 这样就由一张用户表拆分为了用户基本信息表+用户详细信息表，两张表结构不一样相互独立。
- 从这个角度来看垂直拆分并没有从根本上解决单表数据量过大的问题，因此我们还是需要做一次水平拆分。
- 水平拆分:
    - 什么是水平拆分：表中有一万条数据，我们拆分为两张表，id 为奇数的：1、3、5、7……放在 user1；id 为偶数的：2、4、6、8……放在 user2中，这样就是水平拆分了。
    - 水平拆分的方式：按照id拆表，按照时间维度拆分
- 水平拆分和垂直拆分的特点：
    - 垂直切分：基于表或字段划分，表结构不同。
    - 水平切分：基于数据划分，表结构相同，数据不同。

##### 单库内拆分和多库拆分
-  单库内拆分：在单独一个数据库中将一张表拆分为几个子表在一定程度上可以解决单表查询性能的问题
    - 问题：单数据库存储瓶颈。
-  多库拆分：将子表拆分到多个数据库中。比如将用户表拆分为两个子表，两个子表分别存在于不同的数据库中。
    - 这种情况使用比较多
- 分表的作用：分表主要是为了减少单张表的大小，解决单表数据量带来的性能问题。

#### 5. 分库分表带来的复杂性

分库分表的确解决了很多问题，但是也给系统带来了很多复杂性：
- i. 跨库关联查询
单库未拆分表之前，我们可以很方便使用 join 操作关联多张表查询数据，但是经过分库分表后两张表可能都不在一个数据库中，如何使用 join 呢？
    - 字段冗余：把需要关联的字段放入主表中，避免 join 操作；
    - 数据抽象：通过ETL等将数据汇合聚集，生成新的表；
    - 全局表：比如一些基础表可以在每个数据库中都放一份；
    - 应用层组装：将基础数据查出来，通过应用程序计算组装。
- ii. 分布式事务
单数据库可以用本地事务搞定，使用多数据库就只能通过分布式事务解决了。
    - 基于可靠消息（MQ）的解决方案
    - 两阶段事务提交
- iii. 排序、分页、函数计算问题
使用 SQL 时 order by、limit等关键字需要特殊处理，一般来说采用分片的思路
    - 汇总计算结果：先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终得到结果。
- iv. 分布式 ID
在单库单表可以使用 id自增作为主键，分库分表了之后就不行了，会出现 ID重复。
常用的分布式 ID 解决方案有：
    - UUID
    - 基于数据库自增单独维护一张 ID 表
    - 号段模式
    - Redis 缓存
    - 雪花算法（Snowflake）
- v. 多数据源
分库分表之后可能会面临从多个数据库或多个子表中获取数据，一般的解决思路有：客户端适配和代理层适配。
常用的中间件有：
    - shardingsphere（前身 sharding-jdbc）
    - Mycat