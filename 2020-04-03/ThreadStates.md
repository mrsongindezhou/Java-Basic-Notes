## Java 的线程有哪些状态，转换关系是怎么样的？
### Java 的线程有哪些状态
Java API将线程的整个生命周期分为六个状态，分别是NEW（新建状态）、RUNNABLE（可运行状态）、BLOCKED（阻塞状态）、WAITING（等待状态）、TIMED_WAITING（定时等待状态）和TERMINATED（终止状态）。

### 转换关系是怎么样的？
#### 1．NEW（新建状态）
- 创建一个线程对象后，该线程对象就处于新建状态
- 此时它不能运行，和其他Java对象一样，仅仅由JVM为其分配了内存，没有表现出任何线程的动态特征。
#### 2．RUNNABLE（可运行状态）
当新建状态下的线程对象调用了start()方法，此时就会从新建状态进入可运行状态。
- 在RUNNABLE状态内部又可细分成两种状态：READY（就绪状态）和RUNNING（运行状态），并且线程可以在这两个状态之间相互转换。
    - 就绪状态：线程对象调用start()方法之后，等待JVM的调度，此时线程并没有运行；
    - 运行状态：线程对象获得JVM调度，如果存在多个CPU，那么允许多个线程并行运行。
#### 3．BLOCKED（阻塞状态）
处于运行状态的线程可能会因为某些原因失去CPU的执行权，暂时停止运行进入阻塞状态。
- JVM不会给线程分配CPU，直到线程重新进入就绪状态，才有机会转换到运行状态。
- 阻塞状态的线程只能先进入就绪状态，不能直接进入运行状态。

线程一般会在以下两种情况下进入阻塞状态：
- ● 同步锁被抢占：当线程A运行过程中，试图获取同步锁时，却被线程B获取，此时JVM把当前线程A存到对象的锁池中，线程A就会进入阻塞状态；
- ● IO请求：当线程运行过程中，发出IO请求时，此时该线程也会进入阻塞状态。
#### 4．WAITING（等待状态）
当处于运行状态的线程调用了无时间参数限制的方法后，如wait()、join()等方法，就会将当前运行中的线程转换为等待状态。
- 不能立即争夺CPU使用权，必须等待其他线程执行特定的操作后，才有机会再次争夺CPU使用权，将等待状态的线程转换为运行状态。
    - 例如，调用wait()方法而处于等待状态中的线程，必须等待其他线程调用notify()或者notifyAll()方法唤醒当前等待中的线程；调用join()方法而处于等待状态中的线程，必须等待其他加入的线程终止。

#### 5．TIMED_WAITING（定时等待状态）
- 将运行状态中的线程转换为定时等待状态中的线程与转换为等待状态中的线程操作类似，只是运行线程调用了有时间参数限制的方法
    - 如sleep(long millis)、wait(long timeout)、join(long millis)等方法。

- 也不能立即争夺CPU使用权，必须等待其他相关线程执行完特定的操作或者限时时间结束后，才有机会再次争夺CPU使用权，将定时等待状态的线程转换为运行状态。
    - 例如，调用了wait(long timeout) 方法而处于等待状态中的线程，需要通过其他线程调用notify()或者notifyAll()方法唤醒当前等待中的线程，或者等待限时时间结束后也可以进行状态转换。
#### 6．TERMINATED（终止状态）
- 线程的run()方法、call()方法正常执行完毕或者线程抛出一个未捕获的异常（Exception）、错误（Error），线程就进入终止状态。
- 一旦进入终止状态，线程将不再拥有运行的资格，也不能再转换到其他状态，生命周期结束。