## MinorGC 和 Full GC

### 一 MinorGC 和 Full GC区别
- 新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。
- 老年代 GC（Major GC/Full GC）:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。

### 二 minorGC过程详解
- 1.**都为空**： 在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间(S0, S1)都为空。
- 2 **Eden满**：当Eden区满了的时候，minorGC 被触发 。
- 3 **复制到S0**: 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。
- 4 **Eden和S0区满**：在下一次的Minor GC中，Eden区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到survivor区。当Eden 和 s0区空间满了，S0的所有的数据都被复制到S1，需要注意的是，在上次minor GC过程中移动到S0中的两个对象在复制到S1后其年龄要加1。此时Eden区S0区被清空，所有存活的数据都复制到了S1区，并且S1区存在着年龄不一样的对象。
- 5  **对换复制**：再下一次MinorGC则重复这个过程，这一次survivor的两个区对换，存活的对象被复制到S0，存活的对象年龄加1，Eden区和另一个survivor区被清空。
- 6 **Promotion到老年代**：再经过几次Minor GC之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold默认是15），就会被从年轻代Promotion到老年代。
- 7 随着MinorGC一次又一次的进行，不断会有新的对象被promote到老年代。
- 8 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记整理)。

从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换


### 二 MinorGC 和 Full GC触发条件
1. Minor GC触发条件：**Eden区满时**
2. Full GC触发条件：
- （1）调用**System.gc**时，系统建议执行Full GC，但是不必然执行
- （2）**老年**代空间不足
- （3）**方法区**空间不足
- （4）通过Minor GC后进入老年代的平均大小大于老年代的**可用内存**
- （5）由Eden区、From Space区向To Space区复制时，对象**大小大于To Space**可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。


### 三 对象进入老年代的四种情况
- (1) 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代
- (2) 大对象直接进入老年代
    - 假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代
- (3) 长期存活的对象将进入老年代
    - 此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没"熬过"一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中
- (4) 动态对象年龄判定
    - 还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。
