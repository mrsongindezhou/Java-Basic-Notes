## 用户态和内核态

Linux操作系统的体系架构分为用户态和内核态。
### 一、用户态和内核态
#### 1. 内核
本质是一种软件，控制计算机的硬件资源，并提供给上层应用程序运行的环境。
#### 2. 用户态
上层应用程序的活动空间。为了是上层应用能访问CPI资源、存储资源、I/O资源等，内核必须为上层应用提供访问的接口：系统调用。

- 系统调用：是OS的最小功能单位，库函数通过对系统调用的封装，将简单的业务逻辑呈现给上层，方便用户调用。
- Shell：特殊的应用程序，是可编程的，可以执行Shell脚本，脚本的语句通常对系统调用做了封装。
- 用户态的应用程序可以通过三个方式来访问内核态的资源：系统调用、库函数、Shell脚本

### 二、用户态和内核态的切换
- 由于操作系统的资源有限，为了避免资源的过多消耗和使用冲突，Linux对不同的操作赋予了执行等级，特权级。Intel x86架构的CPU有0~3四个特权级，硬件在执行每条指令的时候都会对指令的特权级进行检查。对Linux来说只用到了0和3，最高和最低特权，分别对应了内核态和用户态。也就是说在Linux环境中，0级特权的指令具有CPU的最高执行权利，3级的指令则只有最基本的权利。
- 运行在内核态的进程可以执行任何操作，但是用户态的进行可执行的操作和访问的资源都会受限，这些用户态的进程在执行的过程中，当需要执行内核权限（0级特权）的操作时，需要进程用户到到内核态的切换。
- 例如C库函数的malloc()，它通过sbrk()系统调用来分配内存，当malloc调用sbrk的时候，涉及到用户态到内核态的切换。（系统调用本质是中断，软中断）。

#### 用户态到内核态的切换：
##### ①系统调用
- 用户态进程通过系统调用，申请使用系统提供的服务来完成工作，主动切换到内核态的形式。
##### ②异常
- 当CPU执行用户态的程序，发生不可知的异常，会触发从当前用户态执行的进程转向内核态执行相关的异常事件，进入内核态。例如缺页异常。
##### ③外围设备中断
- 外围设备完成用户的请求之后，向CPU发出中断信号，CPU会暂时执行下一条即将执行的指令，转而去执行中断信号对应的处理程序。如果先执行的指令是用户态的，那么就会转向内核态。例如硬盘读写完成，系统会切换到硬盘读写的中断处理程序中执行后续操作。

这三种方式是系统在运行时，由用户态切换到内核态的主要方式。其中系统调用是由用户进程主动发起的，异常和外围设备中断都是被动的。
