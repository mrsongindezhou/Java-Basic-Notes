## Linux的 IO 模型介绍
一共有五种 IO 模型
- 阻塞 IO
- 非阻塞 IO
- 多路复用 IO
- 信号驱动 IO
- 异步 IO

其中，前面4种是同步IO，最后一个是异步IO
### 一. 阻塞 IO
阻塞IO，就是指当调用读取数据的函数（比如 read），这个函数不立马返回结果，而是阻塞当前进程，直到数据被复制到用户进程空间或者是超时出错才解除阻塞，并返回结果。

##### 应用
- 实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。
##### 缺点
- 这给网络编程带来了一个很大的问题，如在调用 recv(1024) 的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。


### 二. non-block（非阻塞I/O模型）
非阻塞 IO ，用户在调用 read等 方法后，进程不会被阻塞。内核会立马返回数据给进程，这个数据可能是error提示，也可能是最终的结果。如果要得到最终的结果，就需要用户进程主动的多次调用 read 方法。

##### 特点
- 用户进程在内核准备数据的阶段需要不断的主动询问数据好了没有。

##### 缺点
- 轮询调用 read 是很费CPU资源的，所以一般我们会在代码中加入 time.sleep(2)。但是加入了 sleep 以后，任务的执行时间长了，因为我们不确定，任务多久执行完成。

### 三. I/O多路复用

I/O多路复用实际上就是用select , poll, epoll监听多个io对象，当io对象有变化（有数据）的时候就通知用户进程。好处就是单个进程可以处理多个socket。


##### 与blocking IO区别
- blocking IO只调用了一个system call。
- 用多路复用的优势在于它可以同时处理多个connection。

##### 特点
- 通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。
- select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。
- 如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用多线程 + 阻塞 IO的web server性能更好，可能延迟还更大。
- 在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为非阻塞，但是，整个用户的process其实是一直被阻塞的。只不过process是被select这个函数阻塞，而不是被socket IO给阻塞。
　　
##### 典型应用
Java NIO、Nginx（epoll、poll、select）

##### 优缺点
- 专一进程解决多个进程IO的阻塞问题、性能好、Reactor模式
- 实现、开发应用难度较大
- 适用高并发服务应用开发、一个进程/线程响应多个请求


### 四. 信号驱动式IO模型

信号驱动式IO步骤
- 进程预先告知内核、向内核注册一个信号处理函数
- 然后用户进程返回不阻塞
- 当内核数据就绪时会发送一个信号给进程,用户进程便在信号处理函数中调用IO读取数据、
- 实际IO内核拷贝到用户进程的过程还是阻塞的,信号驱动式IO并没有实现真正的异步、因为通知到进程之后、依然是由进程来完成IO操作

##### 特点
- 这和后面的异步IO模型很容易混淆、需要理解IO交互并结合五种IO模型的比较阅读
- 在信号驱动式IO模型中、依然不符合POSIX描述的异步IO、只能算是半异步、并且实际中并不常用、
- 回调机制、实现、开发应用难度大

### 五. 异步IO模型

##### 从用户角度
- 用户进程发起aio_read（POSIX异步IO函数aio_或者lio_开头）操作
- 之后给内核传递描述符、缓冲区指针、缓冲区大小和read相同的三个参数以及文件偏移（与lseek类似），告诉内核当整个操作完成时、如何通知用户
- 用户立刻就可以开始去做其它的事


##### 从内核的角度
- 当它受到一个aio_read之后，首先它会立刻返回，所以不会对用户进程产生任何阻塞
- 然后内核会等待数据准备完成，然后将数据拷贝到用户内存
- 当这一切都完成之后，内核会给用户进程发送一个信号，告诉它aio_read操作完成了


##### 异步IO的工作机制
1. 告知内核启动某个操作
1. 并让内核在整个操作完成后通知用户
1. 这种模型与信号驱动的IO区别在于：
    1. 信号驱动IO是由内核通知我们何时可以启动一个IO操作，这个IO操作由用户自定义的信号函数来实现
    2. 异步IO模型是由内核告知我们IO操作何时完成

在异步IO模型中、真正实现了POSIX描述的异步IO、是五种IO模型中唯一的异步模型

##### 典型应用
Java 7 AIO、高性能服务器应用
##### 特点
- 不阻塞、数据一步到位、Proactor模式
- 需要操作系统的底层支持、LINUX 2.5 版本内核首现、2.6 版本产品的内核标准特性
- 回调机制、实现、开发应用难度大
- 非常适合高性能高并发应用

三、五种IO模型的比较

##### 阻塞IO和非阻塞IO的区别在哪？


- 调用阻塞会一直阻塞住对应的进程直到操作完成
- 非阻塞IO在内核还没准备数据的情况下会立刻返回

阻塞和非阻塞关注的是进程在等待调用结果时的状态

1. 阻塞是指调用结果返回之前,当前进程会被挂起,调用进程只有在得到结果才会返回
1. 非阻塞调用指不能立刻得到结果,该调用不会阻塞当前进程

##### 同步IO和异步IO区别在哪？

- 同步IO主动的调用recvfrom来将数据拷贝到用户内存异步是用户进程将整个IO操作交给了内核完成,内核做完后发信号通知。
在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据

##### 信号驱动式IO和异步IO的区别？

异步IO意味着通知内核启动某个IO操作，并让内核在整个操作（包括数据从内核复制到用户缓冲区）完成时通知用户；
- 异步IO是由内核通知我们IO操作何时完成；
- 信号驱动IO是由内核通知我们何时可以启动一个IO操作。这个IO操作由用户自定义的信号函数来实现。