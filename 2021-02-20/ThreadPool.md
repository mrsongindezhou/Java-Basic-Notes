## 线程池是如何实现的？简述线程池的任务策略

### 线程池是如何实现的？
Java中的线程池核心实现类是ThreadPoolExecutor。
ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。

所以线程池主要由两部分组成，一部分是阻塞队列，另一部分是线程容器。我们可以向阻塞队列中添加任务，根据阻塞队列是否是无界的，java提供了两种不同的队列实现，一是ArrayBlockingQueue,另一是LinkedBlockingQueue。
- 线程容器类可以通过添加一个Set集合来存放活跃的线程，并包含一个阻塞队列的实例，当一个任务被添加时，可以通过判断工作线程的数量与核心线程数的大小，当不足时，可以开启一个新的线程去执行任务，若超出则将任务暂存在任务队列中。
- 任务队列的实现可以是一个简单的ArrayDeque 双端队列，其核心方法是对任务的取出与暂存操作，当需要取出一个任务时，必须进行非空判断，可以通过添加锁机制，例如Reetrantlock来实现锁空队列，当任务被暂存时，通过Condition条件唤醒需要取出任务的线程继续执行任务，从而实现类似生产者与消费者之间的平衡关系。

### 线程池的任务策略
#### 任务提交
对于线程池，可以通俗的将它理解为"存放一定数量线程的一个线程集合。线程池允许若个线程同时允许，允许同时运行的线程数量就是线程池的容量；当添加的到线程池中的线程超过它的容量时，会有一部分线程阻塞等待。线程池会通过相应的调度策略和拒绝策略，对添加到线程池中的线程进行管理。"

即当任务提交后，线程池会根据情况使用三种策略处理任务：
- 直接开启新线程处理任务
- 将任务暂存到队列中
- 拒绝策略

具体来说就是线程池中有corePoolSize是"核心池大小"，maximumPoolSize是"最大池大小"。它们的作用是调整"线程池中实际运行的线程的数量"。
例如，当新任务提交给线程池时(通过execute方法)。
- 情况1  -  如果"线程池中任务数量" < "核心池大小"时，即线程池中少于corePoolSize个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。
- 情况2 - 如果"线程池中任务数量" >= "核心池大小"，并且"线程池是允许状态"；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认"线程池的状态"，如果"第2次读到的线程池状态"和"第1次读到的线程池状态"不同，则从阻塞队列中删除该任务。
- 情况3 - 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过reject()拒绝该任务。

#### 四种拒绝策略：
通过reject()拒绝任务有四种策略：
1. CallerRunsPolicy - 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。
- 使用场景：一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果多次提交任务，可能导致程序阻塞，性能效率上必然的损失较大
2. AbortPolicy - 中止策略，抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。我们在调用线程处必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。
3. DiscardPolicy - 直接丢弃，不执行其他操作
4. DiscardOldestPolicy -  当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列workQueue 中最老的一个任务，并将新任务加入
